import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase-server';
import { fal } from '@fal-ai/serverless-client';
import { sendEmail } from '@/lib/resend';
import { BookReadyEmail } from '@/lib/emails/BookReadyEmail';
import { SENDERS } from '@/lib/senders';

// Force dynamic to allow long-running processes (though Vercel has limits)
export const dynamic = 'force-dynamic';
export const maxDuration = 60; // Attempt to extend duration if allowed (Pro: 300s, Hobby: 10/60s)

export async function POST(req) {
    console.log("üë∑ WORKER START: Generate Book Background Process");

    try {
        const supabase = await createClient();
        const body = await req.json();
        const { bookId } = body;

        if (!bookId) {
            return NextResponse.json({ error: "Missing bookId" }, { status: 400 });
        }

        console.log(`üìò Processing Book ID: ${bookId}`);

        // 1. Fetch Book Data & Personalization
        const { data: book, error: fetchError } = await supabase
            .from('generated_books')
            .select('*')
            .eq('id', bookId)
            .single();

        if (fetchError || !book) {
            console.error("‚ùå Book lookup failed:", fetchError);
            return NextResponse.json({ error: "Book not found" }, { status: 404 });
        }

        // Validate Content
        if (!book.content_json || !Array.isArray(book.content_json.pages)) {
            console.error("‚ùå Invalid book content structure");
            return NextResponse.json({ error: "Invalid content" }, { status: 400 });
        }

        const pages = book.content_json.pages;
        const photoUrl = book.child_photo_url;
        const childGender = book.child_gender; // 'boy' or 'girl'

        let updatedPages = [...pages];
        let hasChanges = false;
        let generatedCount = 0;

        // 2. Iterate pages and generate missing images
        // Note: Page 1 & 2 might already be generated by Preview. We check 'image' field.
        for (let i = 0; i < updatedPages.length; i++) {
            const page = updatedPages[i];

            // If image is missing or is just a placeholder/text
            // Valid image usually starts with http (Fal URL) or /images (static)
            // If it's empty, null, or a specific placeholder we want to replace
            const hasValidImage = page.image && page.image.length > 50 && page.image.startsWith('http');

            if (hasValidImage) {
                console.log(`‚úÖ Page ${i + 1} already has image. Skipping.`);
                continue;
            }

            console.log(`üé® Generating Page ${i + 1}...`);

            try {
                // --- A. PREPARE PROMPT ---
                // Dynamic Gender/Traits
                // Default fallback if gender missing
                const genderTerm = childGender === 'girl' ? 'girl' : 'boy';
                const genderAdjective = childGender === 'girl' ? 'braided hair' : 'short hair';

                // Construct Physical Description (DNA)
                // We could enhance this with DB stored description if we had it
                const physicalAttributes = `cute little african ${genderTerm}, dark skin, ${genderAdjective}`;

                const scenePrompt = `${physicalAttributes}, ${page.imagePrompt || page.text}, pixar style, vibrant colors, masterpiece, best quality, wide shot, cinematic lighting`;

                // --- B. GENERATE SCENE (Flux) ---
                let sceneUrl = null;

                // Check Cache first
                if (page.base_image_url) {
                    console.log(`‚ö°Ô∏è Using Cached Base Image for Page ${i + 1}`);
                    sceneUrl = page.base_image_url;
                } else {
                    console.log(`üñåÔ∏è Calling Flux for Page ${i + 1}...`);
                    const sceneResult = await fal.subscribe("fal-ai/flux/dev", {
                        input: {
                            prompt: scenePrompt,
                            image_size: "landscape_4_3",
                            num_inference_steps: 28,
                            guidance_scale: 3.5,
                            enable_safety_checker: false
                        },
                        logs: true,
                    });
                    const sceneImages = sceneResult.images || sceneResult.data?.images;
                    if (sceneImages?.[0]?.url) {
                        sceneUrl = sceneImages[0].url;
                    }
                }

                if (!sceneUrl) throw new Error("Scene generation returned no URL");

                // --- C. FACE SWAP (If Photo Exists) ---
                let finalImageUrl = sceneUrl;
                if (photoUrl) {
                    console.log(`üé≠ Face Swapping Page ${i + 1}...`);
                    const swapResult = await fal.subscribe("fal-ai/face-swap", {
                        input: {
                            base_image_url: sceneUrl,
                            swap_image_url: photoUrl
                        },
                        logs: true,
                    });
                    const swapImages = swapResult.images || swapResult.data?.images;
                    if (swapImages?.[0]?.url) {
                        finalImageUrl = swapImages[0].url;
                    }
                }

                // Update Page Logic
                updatedPages[i] = {
                    ...page,
                    image: finalImageUrl
                };
                hasChanges = true;
                generatedCount++;

                // Optional: Early save/update to DB (streaming progress) could be done here
                // if we fear timeout. For now, we update at the end or if we hit a batch limit.

            } catch (pErr) {
                console.error(`‚ùå Failed to generate Page ${i + 1}:`, pErr);
                // Continue to next page rather than crashing entire worker
            }
        }

        // 3. Save Context & Send Email
        if (hasChanges) {
            const { error: updateError } = await supabase
                .from('generated_books')
                .update({
                    content_json: { ...book.content_json, pages: updatedPages },
                    status: 'completed' // Mark as fully complete
                })
                .eq('id', bookId);

            if (updateError) {
                console.error("‚ùå Failed to update book in DB:", updateError);
                return NextResponse.json({ error: "DB Update Failed" }, { status: 500 });
            }
            console.log("üíæ Book updated successfully with new images.");

            // 4. Send Email Notification
            if (book.email) {
                console.log(`üìß Sending ready email to ${book.email}...`);
                try {
                    const emailHtml = BookReadyEmail({
                        childName: book.child_name || 'votre enfant',
                        bookTitle: book.title,
                        previewUrl: `${process.env.NEXT_PUBLIC_APP_URL || 'https://kusomakids.com'}/book/${book.id}/preview`
                    });

                    const emailRes = await sendEmail({
                        to: book.email,
                        from: SENDERS.TREASURE, // Updated Sender
                        subject: `L'histoire de ${book.child_name || 'votre enfant'} est pr√™te ! üìñ‚ú®`,
                        html: emailHtml
                    });

                    if (emailRes.success) {
                        console.log("‚úÖ Email sent successfully.");
                    } else {
                        console.error("‚ö†Ô∏è Email warning:", emailRes.error);
                    }
                } catch (emailErr) {
                    console.error("‚ùå Email sending failed:", emailErr);
                }
            } else {
                console.log("‚ö†Ô∏è No email found for this book. Skipping notification.");
            }

        } else {
            console.log("ü§∑‚Äç‚ôÇÔ∏è No changes made (all pages were already present).");
        }

        return NextResponse.json({
            success: true,
            generatedCount,
            message: "Worker finished"
        });

    } catch (error) {
        console.error("üö® Worker Critical Error:", error);
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}

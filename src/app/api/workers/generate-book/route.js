import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase-server';
import { fal } from '@fal-ai/serverless-client';
import { sendEmail } from '@/lib/resend';
import { BookReadyEmail } from '@/lib/emails/BookReadyEmail';
import { SENDERS } from '@/lib/senders';

// Force dynamic to allow long-running processes (though Vercel has limits)
export const dynamic = 'force-dynamic';
export const maxDuration = 60; // Attempt to extend duration if allowed (Pro: 300s, Hobby: 10/60s)

export async function POST(req) {
    console.log("üë∑ WORKER START: Generate Book Background Process");

    try {
        const supabase = await createClient();
        const body = await req.json();
        const { bookId } = body;

        if (!bookId) {
            return NextResponse.json({ error: "Missing bookId" }, { status: 400 });
        }

        console.log(`üìò Processing Book ID: ${bookId}`);

        // 1. Fetch Book Data & Personalization
        const { data: book, error: fetchError } = await supabase
            .from('generated_books')
            .select('*')
            .eq('id', bookId)
            .single();

        if (fetchError || !book) {
            console.error("‚ùå Book lookup failed:", fetchError);
            return NextResponse.json({ error: "Book not found" }, { status: 404 });
        }

        // Validate Content
        if (!book.content_json || !Array.isArray(book.content_json.pages)) {
            console.error("‚ùå Invalid book content structure");
            return NextResponse.json({ error: "Invalid content" }, { status: 400 });
        }

        const pages = book.content_json.pages;
        const photoUrl = book.child_photo_url;
        const childGender = book.child_gender; // 'boy' or 'girl'

        let updatedPages = [...pages];
        let hasChanges = false;
        let generatedCount = 0;

        // 2. Iterate pages and generate missing images
        // Note: Page 1 & 2 might already be generated by Preview. We check 'image' field.
        for (let i = 0; i < updatedPages.length; i++) {
            const page = updatedPages[i];

            // If image is missing or is just a placeholder/text
            // Valid image usually starts with http (Fal URL) or /images (static)
            // If it's empty, null, or a specific placeholder we want to replace
            const hasValidImage = page.image && page.image.length > 50 && page.image.startsWith('http');

            if (hasValidImage) {
                console.log(`‚úÖ Page ${i + 1} already has image. Skipping.`);
                continue;
            }

            console.log(`üé® Generating Page ${i + 1}...`);

            try {
                // --- A. PREPARE PROMPT ---
                // Dynamic Gender/Traits
                // Dynamic Gender/Traits
                const genderTerm = childGender === 'girl' ? 'girl' : 'boy';
                const skinTone = 'dark skin';

                let hairStyle = '';
                if (childGender === 'girl') {
                    // HACK FOR V1: Force specific African styles that work well with Face Swap
                    // "Cornrows with beads" gives much better anchors for Soraya's photo than just "braids"
                    hairStyle = 'cornrows with colorful beads, detailed african hair texture';
                } else {
                    hairStyle = 'short natural afro hair';
                }

                // Construct Physical Description (DNA)
                // 2. Add "High Fidelity" keywords specifically for the face
                const physicalAttributes = `cute little african ${genderTerm}, ${skinTone}, ${hairStyle}, highly detailed face, symmetrical eyes, looking at camera, middle shot`;

                // "centered composition" removed to allow dynamic framing (Medium/Wide shots)
                // Use "environmental portrait" elements
                const composition = "cinematic lighting, detailed background, depth of field, 8k, pixar style, 3d render";

                // Construct Final Prompt
                const scenePrompt = `${physicalAttributes}, ${page.imagePrompt || page.text}, ${composition}, high fidelity, masterpiece, best quality, vibrant colors`;

                // --- B. GENERATE SCENE (Flux) ---
                let sceneUrl = null;

                // Check Cache first
                if (page.base_image_url) {
                    console.log(`‚ö°Ô∏è Using Cached Base Image for Page ${i + 1}`);
                    sceneUrl = page.base_image_url;
                } else {
                    console.log(`üñåÔ∏è Calling Flux for Page ${i + 1}...`);
                    const sceneResult = await fal.subscribe("fal-ai/flux/dev", {
                        input: {
                            prompt: scenePrompt,
                            image_size: "landscape_4_3",
                            num_inference_steps: 30, // Slightly increased steps for quality
                            guidance_scale: 3.5,
                            enable_safety_checker: false
                        },
                        logs: true,
                    });
                    const sceneImages = sceneResult.images || sceneResult.data?.images;
                    if (sceneImages?.[0]?.url) {
                        sceneUrl = sceneImages[0].url;
                    }
                }

                if (!sceneUrl) throw new Error("Scene generation returned no URL");

                // --- C. FACE SWAP (If Photo Exists) ---
                let finalImageUrl = sceneUrl;
                if (photoUrl) {
                    console.log(`üé≠ Face Swapping Page ${i + 1}...`);
                    const swapResult = await fal.subscribe("fal-ai/face-swap", {
                        input: {
                            base_image_url: sceneUrl,
                            swap_image_url: photoUrl
                        },
                        logs: true,
                    });
                    const swapImages = swapResult.images || swapResult.data?.images;
                    if (swapImages?.[0]?.url) {
                        finalImageUrl = swapImages[0].url;
                    }
                }

                // Update Page Logic
                updatedPages[i] = {
                    ...page,
                    image: finalImageUrl,
                    base_image_url: sceneUrl // Cache the base image (Flux) to save money/time on re-runs
                };
                hasChanges = true;
                generatedCount++;

            } catch (pErr) {
                console.error(`‚ùå Failed to generate Page ${i + 1}:`, pErr);
                // Continue to next page rather than crashing entire worker
            }
        }

        // 3. Save Context & Send Email
        if (hasChanges) {
            // Determine Cover Image if missing
            let updates = {
                content_json: { ...book.content_json, pages: updatedPages },
                status: 'completed'
            };

            // Verify Cover Image Personalization
            // If we have a child photo, the cover MUST be personalized (Fal URL). 
            // If it looks like a static asset (e.g. /images/...), replace it with Page 1 (which is definitely swapped).
            const isCoverPersonalized = book.cover_url && (book.cover_url.includes('fal.media') || book.cover_url.includes('fal.ai'));

            if (photoUrl && !isCoverPersonalized) {
                console.log("‚ö†Ô∏è Detected non-personalized cover with Child Photo. Attempting fix...");
                if (updatedPages.length > 0 && updatedPages[0].image) {
                    console.log("‚ôªÔ∏è Fixing Cover: Overwriting static cover with personalized Page 1.");
                    updates.cover_url = updatedPages[0].image;
                }
            } else if (!book.cover_url && updatedPages.length > 0 && updatedPages[0].image) {
                // Fallback for missing cover
                console.log("üñºÔ∏è Setting missing cover image from Page 1");
                updates.cover_url = updatedPages[0].image;
            }

            const { error: updateError } = await supabase
                .from('generated_books')
                .update(updates)
                .eq('id', bookId);

            if (updateError) {
                console.error("‚ùå Failed to update book in DB:", updateError);
                return NextResponse.json({ error: "DB Update Failed" }, { status: 500 });
            }
            console.log("üíæ Book updated successfully with new images.");

            // 4. Send Email Notification
            if (book.email) {
                console.log(`üìß Sending ready email to ${book.email}...`);
                try {
                    const emailHtml = BookReadyEmail({
                        childName: book.child_name || 'votre enfant',
                        bookTitle: book.title,
                        previewUrl: `${process.env.NEXT_PUBLIC_APP_URL || 'https://kusomakids.com'}/book/${book.id}/preview`
                    });

                    const emailRes = await sendEmail({
                        to: book.email,
                        from: SENDERS.TREASURE, // Updated Sender
                        subject: `L'histoire de ${book.child_name || 'votre enfant'} est pr√™te ! üìñ‚ú®`,
                        html: emailHtml
                    });

                    if (emailRes.success) {
                        console.log("‚úÖ Email sent successfully.");
                    } else {
                        console.error("‚ö†Ô∏è Email warning:", emailRes.error);
                    }
                } catch (emailErr) {
                    console.error("‚ùå Email sending failed:", emailErr);
                }
            } else {
                console.log("‚ö†Ô∏è No email found for this book. Skipping notification.");
            }

        } else {
            console.log("ü§∑‚Äç‚ôÇÔ∏è No changes made (all pages were already present).");
        }

        return NextResponse.json({
            success: true,
            generatedCount,
            message: "Worker finished"
        });

    } catch (error) {
        console.error("üö® Worker Critical Error:", error);
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}
